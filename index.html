<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regula Falsi Method | Numerical Methods Calculator</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=JetBrains+Mono:wght@400;500&family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --bg-primary: #fdfdf9;
            --bg-secondary: #f5f3ed;
            --bg-tertiary: #ebe8dd;
            --text-primary: #1a1614;
            --text-secondary: #4a443e;
            --text-muted: #6e675e;
            --accent-primary: #8b4513;
            --accent-secondary: #d4a574;
            --accent-light: #f4e4cc;
            --border-color: #d4cec1;
            --success: #2d5016;
            --error: #8b1e1e;
            --warning: #8b6914;
            --shadow: rgba(26, 22, 20, 0.08);
            --shadow-lg: rgba(26, 22, 20, 0.15);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1614;
            --bg-secondary: #242018;
            --bg-tertiary: #2e2920;
            --text-primary: #f5f3ed;
            --text-secondary: #cec9be;
            --text-muted: #9e9588;
            --accent-primary: #d4a574;
            --accent-secondary: #8b4513;
            --accent-light: #3d3020;
            --border-color: #3d3528;
            --success: #6b8e4e;
            --error: #d45d5d;
            --warning: #d4a547;
            --shadow: rgba(0, 0, 0, 0.3);
            --shadow-lg: rgba(0, 0, 0, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.7;
            transition: background 0.4s ease, color 0.4s ease;
            overflow-x: hidden;
        }

        /* Header */
        header {
            position: fixed;
            top: 0;
            width: 100%;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
            z-index: 1000;
            backdrop-filter: blur(10px);
            transition: all 0.4s ease;
        }

        nav {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.2rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            font-weight: 900;
            color: var(--accent-primary);
            letter-spacing: -0.5px;
        }

        .theme-toggle {
            width: 50px;
            height: 26px;
            background: var(--bg-tertiary);
            border-radius: 13px;
            border: 1px solid var(--border-color);
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-toggle::before {
            content: '‚òÄ';
            position: absolute;
            left: 3px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
            transition: all 0.3s ease;
        }

        [data-theme="dark"] .theme-toggle::before {
            content: '‚òæ';
            left: calc(100% - 23px);
        }

        /* Hero Section */
        .hero {
            margin-top: 80px;
            padding: 6rem 2rem 4rem;
            text-align: center;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, var(--accent-light) 0%, transparent 30%),
                radial-gradient(circle at 80% 70%, var(--accent-light) 0%, transparent 30%);
            opacity: 0.3;
            pointer-events: none;
        }

        .hero-content {
            max-width: 900px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .hero h1 {
            font-family: 'Playfair Display', serif;
            font-size: clamp(2.5rem, 6vw, 4.5rem);
            font-weight: 900;
            color: var(--accent-primary);
            margin-bottom: 1rem;
            line-height: 1.1;
            animation: fadeInUp 0.8s ease;
        }

        .hero .subtitle {
            font-size: clamp(1.1rem, 2vw, 1.4rem);
            color: var(--text-secondary);
            margin-bottom: 2.5rem;
            font-weight: 300;
            animation: fadeInUp 0.8s ease 0.2s both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        /* Sections */
        section {
            padding: 4rem 0;
            animation: fadeIn 0.6s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .section-title {
            font-family: 'Playfair Display', serif;
            font-size: clamp(2rem, 4vw, 3rem);
            font-weight: 700;
            color: var(--accent-primary);
            margin-bottom: 2rem;
            text-align: center;
        }

        /* Cards */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 2.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px var(--shadow);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 30px var(--shadow-lg);
        }

        .card h3 {
            font-family: 'Playfair Display', serif;
            font-size: 1.8rem;
            color: var(--accent-primary);
            margin-bottom: 1.2rem;
        }

        .card p, .card li {
            color: var(--text-secondary);
            margin-bottom: 1rem;
            font-size: 1.05rem;
        }

        .card ul, .card ol {
            margin-left: 1.5rem;
        }

        /* Formula Display */
        .formula {
            background: var(--bg-tertiary);
            border-left: 4px solid var(--accent-primary);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            text-align: center;
            overflow-x: auto;
        }

        /* Collapsible Sections */
        .collapsible {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .collapsible::after {
            content: '‚ñº';
            font-size: 0.8rem;
            transition: transform 0.3s ease;
        }

        .collapsible.active::after {
            transform: rotate(-180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease;
        }

        .collapsible-content.active {
            max-height: 3000px;
        }

        /* Calculator Section */
        .calculator {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-secondary);
            border-radius: 16px;
            padding: 3rem;
            box-shadow: 0 8px 40px var(--shadow-lg);
        }

        .input-group {
            margin-bottom: 1.8rem;
        }

        .input-group label {
            display: block;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.6rem;
            font-size: 1.05rem;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 0.9rem 1.2rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 1rem;
            font-family: 'JetBrains Mono', monospace;
            transition: all 0.3s ease;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px var(--accent-light);
        }

        .input-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        /* Buttons */
        .btn {
            padding: 1rem 2.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1.05rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Crimson Pro', serif;
        }

        .btn-primary {
            background: var(--accent-primary);
            color: white;
            box-shadow: 0 4px 15px var(--shadow);
        }

        .btn-primary:hover {
            background: var(--accent-secondary);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow-lg);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-primary);
        }

        .btn-export {
            background: var(--success);
            color: white;
        }

        .btn-export:hover {
            background: #3d6a1f;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Results Section */
        .results {
            margin-top: 3rem;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .iteration-display {
            background: var(--bg-tertiary);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .iteration-display h3 {
            color: var(--accent-primary);
            margin-bottom: 1.2rem;
            font-family: 'Playfair Display', serif;
        }

        .calculation-step {
            background: var(--bg-primary);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.8rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            border-left: 3px solid var(--accent-secondary);
        }

        .calculation-step strong {
            color: var(--accent-primary);
        }

        /* Table */
        .table-container {
            overflow-x: auto;
            margin-top: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 20px var(--shadow);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-secondary);
        }

        th, td {
            padding: 1rem;
            text-align: center;
            border: 1px solid var(--border-color);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
        }

        th {
            background: var(--accent-primary);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        tr:hover {
            background: var(--bg-tertiary);
        }

        tr.converged {
            background: var(--accent-light);
            font-weight: 600;
        }

        /* Progress Indicator */
        .progress-container {
            margin: 2rem 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        .progress-text {
            text-align: center;
            margin-top: 0.5rem;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Alert Messages */
        .alert {
            padding: 1.2rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border-left: 4px solid;
            animation: slideDown 0.4s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert-error {
            background: rgba(139, 30, 30, 0.1);
            border-color: var(--error);
            color: var(--error);
        }

        .alert-success {
            background: rgba(45, 80, 22, 0.1);
            border-color: var(--success);
            color: var(--success);
        }

        .alert-warning {
            background: rgba(139, 105, 20, 0.1);
            border-color: var(--warning);
            color: var(--warning);
        }

        /* Example Box */
        .example-box {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 2rem;
            margin: 2rem 0;
        }

        .example-step {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .example-step:last-child {
            border-bottom: none;
        }

        .example-step h4 {
            color: var(--accent-primary);
            margin-bottom: 0.8rem;
            font-size: 1.2rem;
        }

        /* Footer */
        footer {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 3rem 2rem;
            text-align: center;
            margin-top: 4rem;
        }

        footer p {
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 768px) {
            nav {
                padding: 1rem;
            }

            .hero {
                padding: 4rem 1rem 2rem;
            }

            .card, .calculator {
                padding: 1.5rem;
            }

            .input-row {
                grid-template-columns: 1fr;
            }

            .btn {
                width: 100%;
                margin-bottom: 0.8rem;
            }

            table {
                font-size: 0.75rem;
            }

            th, td {
                padding: 0.6rem;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--accent-light);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Hide/Show utilities */
        .hidden {
            display: none !important;
        }

        .visible {
            display: block;
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            color: var(--accent-primary);
            font-weight: 600;
            border-bottom: 1px dotted var(--accent-primary);
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 280px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            text-align: left;
            border-radius: 8px;
            padding: 1rem;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -140px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px var(--shadow-lg);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--bg-tertiary) transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Quick Presets */
        .presets-container {
            display: flex;
            gap: 0.8rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .preset-btn {
            padding: 0.6rem 1.2rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
        }

        .preset-btn:hover {
            background: var(--accent-light);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        /* Graph Container */
        .graph-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 4px 20px var(--shadow);
        }

        .graph-container h3 {
            color: var(--accent-primary);
            margin-bottom: 1.5rem;
            font-family: 'Playfair Display', serif;
        }

        #functionGraph {
            max-width: 100%;
            height: auto;
        }

        /* Copy Button */
        .copy-btn {
            padding: 0.4rem 0.8rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            margin-left: 0.5rem;
            transition: all 0.2s ease;
        }

        .copy-btn:hover {
            background: var(--accent-light);
            border-color: var(--accent-primary);
        }

        /* Validation indicators */
        .input-valid {
            border-color: var(--success) !important;
        }

        .input-invalid {
            border-color: var(--error) !important;
        }

        .validation-message {
            font-size: 0.85rem;
            margin-top: 0.4rem;
            display: block;
        }

        .validation-success {
            color: var(--success);
        }

        .validation-error {
            color: var(--error);
        }

        /* Keyboard shortcuts hint */
        .keyboard-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 15px var(--shadow-lg);
            max-width: 250px;
            z-index: 999;
            animation: slideInRight 0.5s ease;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .keyboard-hint h4 {
            font-size: 0.95rem;
            margin-bottom: 0.8rem;
            color: var(--accent-primary);
        }

        .keyboard-hint ul {
            list-style: none;
            font-size: 0.85rem;
        }

        .keyboard-hint li {
            margin-bottom: 0.5rem;
        }

        .kbd {
            background: var(--bg-tertiary);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            border: 1px solid var(--border-color);
        }

        .close-hint {
            float: right;
            cursor: pointer;
            font-weight: bold;
            color: var(--text-muted);
        }

        .close-hint:hover {
            color: var(--text-primary);
        }

        /* Smooth scroll indicator */
        .scroll-indicator {
            position: fixed;
            top: 80px;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--bg-tertiary);
            z-index: 999;
        }

        .scroll-progress {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            width: 0%;
            transition: width 0.1s ease;
        }

        /* Help button */
        .help-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 15px var(--shadow-lg);
            transition: all 0.3s ease;
            z-index: 998;
        }

        .help-btn:hover {
            transform: scale(1.1);
            background: var(--accent-secondary);
        }

        /* Statistics Card */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .stat-card {
            background: var(--bg-tertiary);
            padding: 1.5rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .stat-card .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-primary);
            font-family: 'JetBrains Mono', monospace;
        }

        .stat-card .stat-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }

        /* Compare mode */
        .compare-mode {
            background: var(--accent-light);
            border: 2px dashed var(--accent-primary);
            padding: 1.5rem;
            border-radius: 8px;
            margin-top: 2rem;
        }

        /* Enhanced mobile experience */
        @media (max-width: 768px) {
            .keyboard-hint {
                display: none;
            }

            .help-btn {
                bottom: 80px;
            }

            .tooltip .tooltiptext {
                width: 200px;
                margin-left: -100px;
            }

            .presets-container {
                gap: 0.5rem;
            }

            .preset-btn {
                padding: 0.5rem 0.8rem;
                font-size: 0.8rem;
            }

            .stat-card .stat-value {
                font-size: 1.5rem;
            }
        }

        /* Print styles */
        @media print {
            header, footer, .theme-toggle, .btn, .help-btn, .keyboard-hint, .scroll-indicator {
                display: none !important;
            }

            .card, .calculator {
                box-shadow: none !important;
                page-break-inside: avoid;
            }
        }
    </style>
</head>
<body data-theme="light">
    <!-- Header -->
    <header>
        <nav>
            <div class="logo">Regula Falsi</div>
            <div class="theme-toggle" onclick="toggleTheme()"></div>
        </nav>
    </header>

    <!-- Hero Section -->
    <section class="hero">
        <div class="hero-content">
            <h1>Regula Falsi Method</h1>
            <p class="subtitle">An elegant iterative approach to finding roots of non-linear equations through linear interpolation</p>
        </div>
    </section>

    <!-- Main Content -->
    <main class="container">
        <!-- Introduction -->
        <section id="introduction">
            <div class="card">
                <h3 class="collapsible active">What is the Regula Falsi Method?</h3>
                <div class="collapsible-content active">
                    <p>The <strong>Regula Falsi method</strong>, also known as the <strong>Method of False Position</strong>, is a numerical technique for finding approximate roots of real-valued continuous functions. It combines the reliability of the bisection method with faster convergence by using linear interpolation instead of simple bisection.</p>
                    
                    <p>This method is particularly effective when you have an interval [a, b] where the function changes sign, guaranteeing the presence of at least one root within that interval. Unlike the bisection method which always divides the interval in half, Regula Falsi uses the function values to make a more informed choice about where the root might lie.</p>
                    
                    <p><strong>Historical Context:</strong> The method has ancient origins, with early forms appearing in Indian mathematical texts and later refined by European mathematicians. The name "Regula Falsi" comes from Latin, meaning "rule of false position."</p>
                </div>
            </div>
        </section>

        <!-- Mathematical Formula -->
        <section id="formula">
            <h2 class="section-title">Mathematical Formula</h2>
            <div class="card">
                <h3>The Regula Falsi Formula</h3>
                <p>Given two points (a, f(a)) and (b, f(b)) where f(a) and f(b) have opposite signs, the next approximation x is calculated using:</p>
                
                <div class="formula">
                    x = a - [f(a) √ó (b - a)] / [f(b) - f(a)]
                </div>
                
                <p style="text-align: center; margin-top: 1rem;"><em>or equivalently</em></p>
                
                <div class="formula">
                    x = [a √ó f(b) - b √ó f(a)] / [f(b) - f(a)]
                </div>
                
                <p>This formula represents the x-intercept of the straight line connecting the points (a, f(a)) and (b, f(b)). The method then updates the interval based on which side of x the root lies.</p>
            </div>
        </section>

        <!-- Algorithm -->
        <section id="algorithm">
            <h2 class="section-title">Algorithm Steps</h2>
            <div class="card">
                <h3>Step-by-Step Procedure</h3>
                <ol>
                    <li><strong>Initialize:</strong> Choose two initial points a and b such that f(a) √ó f(b) < 0 (opposite signs), ensuring a root exists in [a, b].</li>
                    
                    <li><strong>Calculate New Approximation:</strong> Compute x using the Regula Falsi formula:<br>
                    <span style="font-family: 'JetBrains Mono', monospace; display: block; margin: 0.5rem 0;">x = a - [f(a) √ó (b - a)] / [f(b) - f(a)]</span></li>
                    
                    <li><strong>Evaluate Function:</strong> Calculate f(x) at the new approximation.</li>
                    
                    <li><strong>Check Convergence:</strong> If |f(x)| < Œµ (tolerance) or the error criterion is met, accept x as the root and stop.</li>
                    
                    <li><strong>Update Interval:</strong> 
                        <ul>
                            <li>If f(a) √ó f(x) < 0, the root lies in [a, x], so set b = x</li>
                            <li>If f(x) √ó f(b) < 0, the root lies in [x, b], so set a = x</li>
                        </ul>
                    </li>
                    
                    <li><strong>Iterate:</strong> Return to step 2 and repeat until convergence or maximum iterations reached.</li>
                </ol>
            </div>
        </section>

        <!-- Working Principle -->
        <section id="principle">
            <h2 class="section-title">Working Principle</h2>
            <div class="card">
                <h3>How It Works</h3>
                <p>The Regula Falsi method operates on a geometric principle:</p>
                
                <p><strong>Linear Interpolation:</strong> Instead of blindly bisecting the interval, the method draws a straight line (secant) between the two endpoints (a, f(a)) and (b, f(b)). The x-intercept of this line provides the next approximation.</p>
                
                <p><strong>Bracketing:</strong> Like the bisection method, Regula Falsi maintains a bracket around the root. At each iteration, one endpoint of the interval is replaced with the new approximation, always ensuring the root remains bracketed.</p>
                
                <p><strong>Convergence Behavior:</strong> The method typically converges faster than bisection because it uses function values to make intelligent guesses. However, in some cases, one endpoint may remain fixed while the other converges to the root (called "slow convergence").</p>
                
                <p><strong>Geometric Interpretation:</strong> Imagine connecting two points on a curve with a straight line. Where this line crosses the x-axis is likely closer to where the curve itself crosses the x-axis compared to simply taking the midpoint.</p>
            </div>
        </section>

        <!-- Advantages & Limitations -->
        <section id="pros-cons">
            <h2 class="section-title">Advantages & Limitations</h2>
            <div class="input-row">
                <div class="card" style="background: rgba(45, 80, 22, 0.05);">
                    <h3 style="color: var(--success);">‚úì Advantages</h3>
                    <ul>
                        <li><strong>Guaranteed Convergence:</strong> Always converges to a root if the initial interval brackets it</li>
                        <li><strong>No Derivative Required:</strong> Only function evaluations needed, no calculus</li>
                        <li><strong>Faster than Bisection:</strong> Generally converges faster due to linear interpolation</li>
                        <li><strong>Simple Implementation:</strong> Straightforward algorithm, easy to code</li>
                        <li><strong>Robust:</strong> Handles many types of continuous functions reliably</li>
                        <li><strong>Visual Clarity:</strong> Geometric interpretation makes it intuitive</li>
                    </ul>
                </div>
                
                <div class="card" style="background: rgba(139, 30, 30, 0.05);">
                    <h3 style="color: var(--error);">‚úó Limitations</h3>
                    <ul>
                        <li><strong>Slower than Newton's Method:</strong> Linear convergence vs quadratic</li>
                        <li><strong>One Endpoint May Stagnate:</strong> Can have slow convergence in some cases</li>
                        <li><strong>Requires Bracket:</strong> Must find initial interval where function changes sign</li>
                        <li><strong>Only One Root:</strong> Finds only one root in the given interval</li>
                        <li><strong>Function Evaluation:</strong> May be slow for computationally expensive functions</li>
                        <li><strong>Not Suitable for Multiple Roots:</strong> Struggles with roots of even multiplicity</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Applications -->
        <section id="applications">
            <h2 class="section-title">Real-Life Applications</h2>
            <div class="card">
                <h3>Where Regula Falsi is Used</h3>
                <ul>
                    <li><strong>Engineering Design:</strong> Finding equilibrium points in mechanical systems, stress-strain analysis, and structural optimization</li>
                    
                    <li><strong>Financial Mathematics:</strong> Calculating internal rate of return (IRR), break-even analysis, and solving bond pricing equations</li>
                    
                    <li><strong>Physics & Astronomy:</strong> Solving transcendental equations in orbital mechanics, wave propagation, and quantum mechanics</li>
                    
                    <li><strong>Chemical Engineering:</strong> Determining reaction equilibrium, solving mass balance equations, and process optimization</li>
                    
                    <li><strong>Electrical Engineering:</strong> Circuit analysis, finding operating points in non-linear circuits, and control system design</li>
                    
                    <li><strong>Economics:</strong> Market equilibrium calculations, supply-demand intersection, and economic modeling</li>
                    
                    <li><strong>Environmental Science:</strong> Pollution dispersion models, climate modeling, and resource management</li>
                    
                    <li><strong>Computer Graphics:</strong> Ray-tracing algorithms, collision detection, and surface intersection calculations</li>
                </ul>
            </div>
        </section>

        <!-- Solved Example -->
        <section id="example">
            <h2 class="section-title">Manually Solved Example</h2>
            <div class="card">
                <h3>Example Problem</h3>
                <p><strong>Find the root of f(x) = x¬≥ - x - 1 in the interval [1, 2] using the Regula Falsi method (tolerance = 0.01)</strong></p>
                
                <div class="example-box">
                    <div class="example-step">
                        <h4>Step 1: Verify Initial Conditions</h4>
                        <p>Given: a = 1, b = 2</p>
                        <p>f(a) = f(1) = 1¬≥ - 1 - 1 = -1</p>
                        <p>f(b) = f(2) = 2¬≥ - 2 - 1 = 5</p>
                        <p>Since f(1) √ó f(2) = -1 √ó 5 = -5 < 0, a root exists in [1, 2] ‚úì</p>
                    </div>
                    
                    <div class="example-step">
                        <h4>Iteration 1</h4>
                        <div class="formula">
                            x‚ÇÅ = a - [f(a) √ó (b - a)] / [f(b) - f(a)]
                        </div>
                        <div class="formula">
                            x‚ÇÅ = 1 - [(-1) √ó (2 - 1)] / [5 - (-1)]
                        </div>
                        <div class="formula">
                            x‚ÇÅ = 1 - [(-1) √ó 1] / 6 = 1 - (-1/6) = 1 + 0.1667 = 1.1667
                        </div>
                        <p>f(x‚ÇÅ) = f(1.1667) = (1.1667)¬≥ - 1.1667 - 1 = 1.5854 - 1.1667 - 1 = -0.5813</p>
                        <p>Since f(1) √ó f(x‚ÇÅ) = -1 √ó -0.5813 = 0.5813 > 0, root is in [x‚ÇÅ, 2]</p>
                        <p>Update: a = 1.1667, b = 2</p>
                    </div>
                    
                    <div class="example-step">
                        <h4>Iteration 2</h4>
                        <div class="formula">
                            x‚ÇÇ = 1.1667 - [(-0.5813) √ó (2 - 1.1667)] / [5 - (-0.5813)]
                        </div>
                        <div class="formula">
                            x‚ÇÇ = 1.1667 - [(-0.5813) √ó 0.8333] / 5.5813
                        </div>
                        <div class="formula">
                            x‚ÇÇ = 1.1667 + 0.4844 / 5.5813 = 1.1667 + 0.0868 = 1.2535
                        </div>
                        <p>f(x‚ÇÇ) = f(1.2535) = (1.2535)¬≥ - 1.2535 - 1 = -0.2848</p>
                        <p>Update: a = 1.2535, b = 2</p>
                    </div>
                    
                    <div class="example-step">
                        <h4>Iteration 3</h4>
                        <div class="formula">
                            x‚ÇÉ = 1.2535 - [(-0.2848) √ó (2 - 1.2535)] / [5 - (-0.2848)]
                        </div>
                        <div class="formula">
                            x‚ÇÉ = 1.2535 + 0.2126 / 5.2848 = 1.2535 + 0.0402 = 1.2937
                        </div>
                        <p>f(x‚ÇÉ) = f(1.2937) = -0.1293</p>
                        <p>Update: a = 1.2937, b = 2</p>
                    </div>
                    
                    <div class="example-step">
                        <h4>Iteration 4</h4>
                        <div class="formula">
                            x‚ÇÑ = 1.2937 - [(-0.1293) √ó (2 - 1.2937)] / [5 - (-0.1293)]
                        </div>
                        <div class="formula">
                            x‚ÇÑ = 1.2937 + 0.0913 / 5.1293 = 1.2937 + 0.0178 = 1.3115
                        </div>
                        <p>f(x‚ÇÑ) = f(1.3115) = -0.0568</p>
                        <p>Update: a = 1.3115, b = 2</p>
                    </div>
                    
                    <div class="example-step">
                        <h4>Iteration 5</h4>
                        <div class="formula">
                            x‚ÇÖ = 1.3115 + 0.0401 / 5.0568 = 1.3195
                        </div>
                        <p>f(x‚ÇÖ) = f(1.3195) = -0.0245</p>
                        <p>|f(x‚ÇÖ)| = 0.0245 < 0.01? No, continue...</p>
                    </div>
                    
                    <div class="example-step">
                        <h4>Iteration 6</h4>
                        <div class="formula">
                            x‚ÇÜ = 1.3247
                        </div>
                        <p>f(x‚ÇÜ) = f(1.3247) = -0.0105</p>
                        <p>|f(x‚ÇÜ)| = 0.0105 ‚âà 0.01? Close enough!</p>
                    </div>
                    
                    <div class="example-step" style="border: 2px solid var(--success); background: rgba(45, 80, 22, 0.05);">
                        <h4>‚úì Solution</h4>
                        <p><strong>Approximate root: x ‚âà 1.3247</strong></p>
                        <p>The actual root is approximately 1.3247, which our method successfully found in 6 iterations!</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Interactive Calculator -->
        <section id="calculator">
            <h2 class="section-title">Interactive Solver</h2>
            <div class="calculator">
                <h3 style="margin-bottom: 2rem; color: var(--accent-primary); font-family: 'Playfair Display', serif;">Calculate Roots Using Regula Falsi Method</h3>
                
                <!-- Quick Presets -->
                <div style="margin-bottom: 2rem;">
                    <label style="display: block; margin-bottom: 0.8rem; font-weight: 600;">
                        <span class="tooltip">Quick Examples
                            <span class="tooltiptext">Click any example to auto-fill the calculator with a pre-configured problem</span>
                        </span>
                    </label>
                    <div class="presets-container">
                        <button class="preset-btn" onclick="loadPreset('x^3 - x - 1', 1, 2)">x¬≥ - x - 1</button>
                        <button class="preset-btn" onclick="loadPreset('x^2 - 4', 1, 3)">x¬≤ - 4</button>
                        <button class="preset-btn" onclick="loadPreset('cos(x) - x', 0, 1)">cos(x) - x</button>
                        <button class="preset-btn" onclick="loadPreset('e^x - 3*x', 0, 2)">eÀ£ - 3x</button>
                        <button class="preset-btn" onclick="loadPreset('x*log(x) - 1', 2, 3)">x¬∑log(x) - 1</button>
                        <button class="preset-btn" onclick="loadPreset('sin(x) - 0.5', 0, 1)">sin(x) - 0.5</button>
                    </div>
                </div>

                <div class="input-group">
                    <label for="function">
                        <span class="tooltip">Enter Function f(x)
                            <span class="tooltiptext">
                                <strong>Supported operators:</strong><br>
                                +, -, *, /, ^ (power)<br><br>
                                <strong>Functions:</strong><br>
                                sqrt(), sin(), cos(), tan(), log(), ln(), exp(), abs(), asin(), acos(), atan()<br><br>
                                <strong>Constants:</strong><br>
                                e, pi
                            </span>
                        </span>:
                    </label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="text" id="function" placeholder="e.g., x^3 - x - 1" value="x^3 - x - 1" oninput="validateFunction()">
                        <button class="copy-btn" onclick="copyToClipboard('function')" title="Copy function">üìã</button>
                    </div>
                    <span id="functionValidation" class="validation-message"></span>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="useBounds" checked>
                    <label for="useBounds">
                        <span class="tooltip">Specify interval [a, b]
                            <span class="tooltiptext">Providing an interval where f(a) and f(b) have opposite signs guarantees finding a root. If unchecked, the system will try to find an interval automatically.</span>
                        </span>
                    </label>
                </div>

                <div class="input-row" id="boundsInputs">
                    <div class="input-group">
                        <label for="lowerBound">Lower Bound (a):</label>
                        <input type="number" id="lowerBound" step="any" value="1" oninput="validateBounds()">
                    </div>
                    <div class="input-group">
                        <label for="upperBound">Upper Bound (b):</label>
                        <input type="number" id="upperBound" step="any" value="2" oninput="validateBounds()">
                    </div>
                </div>
                <span id="boundsValidation" class="validation-message"></span>

                <div class="input-row">
                    <div class="input-group">
                        <label for="errorType">
                            <span class="tooltip">Error Calculation Type
                                <span class="tooltiptext">
                                    <strong>Absolute Error:</strong> |x‚Çô - x‚Çô‚Çã‚ÇÅ|<br><br>
                                    <strong>Relative Error:</strong> |x‚Çô - x‚Çô‚Çã‚ÇÅ| / |x‚Çô| √ó 100%<br><br>
                                    Relative error is better for comparing convergence across different scales.
                                </span>
                            </span>:
                        </label>
                        <select id="errorType">
                            <option value="absolute">Absolute Error</option>
                            <option value="relative">Relative Percentage Error</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="tolerance">
                            <span class="tooltip">Tolerance (Œµ)
                                <span class="tooltiptext">The method stops when error falls below this value. Smaller tolerance = more accurate result but more iterations.</span>
                            </span>:
                        </label>
                        <input type="number" id="tolerance" step="any" value="0.0001" min="0.000001">
                    </div>
                </div>

                <div class="input-row">
                    <div class="input-group">
                        <label for="precision">
                            <span class="tooltip">Decimal Precision
                                <span class="tooltiptext">Number of digits displayed after the decimal point in results (1-15)</span>
                            </span>:
                        </label>
                        <input type="number" id="precision" min="1" max="15" value="6">
                    </div>
                    <div class="input-group">
                        <label for="maxIterations">
                            <span class="tooltip">Maximum Iterations
                                <span class="tooltiptext">Safety limit to prevent infinite loops. Increase if the method doesn't converge.</span>
                            </span>:
                        </label>
                        <input type="number" id="maxIterations" min="1" max="1000" value="100">
                    </div>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="showGraph" checked>
                    <label for="showGraph">
                        <span class="tooltip">Show Function Graph
                            <span class="tooltiptext">Visualize the function and see where roots are located graphically</span>
                        </span>
                    </label>
                </div>

                <div style="display: flex; gap: 1rem; margin-top: 2rem; flex-wrap: wrap;">
                    <button class="btn btn-primary" onclick="solveRegulaFalsi()" title="Press Ctrl+Enter">
                        üöÄ Solve & Show First Iteration
                    </button>
                    <button class="btn btn-secondary" onclick="resetCalculator()">
                        üîÑ Reset
                    </button>
                    <button class="btn btn-secondary" onclick="toggleCompareMode()" id="compareBtn">
                        üìä Compare with Bisection
                    </button>
                </div>

                <div id="errorMessage"></div>
                <div id="resultsSection" class="hidden"></div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer>
        <p>&copy; 2024 Regula Falsi Method Calculator | A Comprehensive Academic Tool for Numerical Methods</p>
        <p style="margin-top: 0.5rem; font-size: 0.9rem;">Designed for students, educators, and engineers</p>
    </footer>

    <!-- Scroll Progress Indicator -->
    <div class="scroll-indicator">
        <div class="scroll-progress" id="scrollProgress"></div>
    </div>

    <!-- Help Button -->
    <button class="help-btn" onclick="toggleKeyboardHints()" title="Keyboard Shortcuts">?</button>

    <!-- Keyboard Shortcuts Hint -->
    <div class="keyboard-hint hidden" id="keyboardHints">
        <span class="close-hint" onclick="toggleKeyboardHints()">√ó</span>
        <h4>‚å®Ô∏è Keyboard Shortcuts</h4>
        <ul>
            <li><span class="kbd">Ctrl+Enter</span> - Solve</li>
            <li><span class="kbd">Ctrl+R</span> - Reset</li>
            <li><span class="kbd">Ctrl+D</span> - Toggle Dark Mode</li>
            <li><span class="kbd">Esc</span> - Close Hints</li>
        </ul>
    </div>

    <script>
        // Theme Toggle
        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }

        // Load saved theme
        window.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.body.setAttribute('data-theme', savedTheme);
            
            // Setup collapsible sections
            document.querySelectorAll('.collapsible').forEach(elem => {
                elem.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const content = this.nextElementSibling;
                    content.classList.toggle('active');
                });
            });

            // Bounds checkbox toggle
            document.getElementById('useBounds').addEventListener('change', function() {
                document.getElementById('boundsInputs').style.display = this.checked ? 'grid' : 'none';
            });

            // Scroll progress indicator
            window.addEventListener('scroll', updateScrollProgress);

            // Show welcome hint
            setTimeout(() => {
                if (!localStorage.getItem('hintsShown')) {
                    toggleKeyboardHints();
                    localStorage.setItem('hintsShown', 'true');
                }
            }, 2000);
        });

        // Scroll progress
        function updateScrollProgress() {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('scrollProgress').style.width = scrolled + '%';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+Enter to solve
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                solveRegulaFalsi();
            }
            // Ctrl+R to reset
            if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                resetCalculator();
            }
            // Ctrl+D to toggle theme
            if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                toggleTheme();
            }
            // Esc to close hints
            if (e.key === 'Escape') {
                const hints = document.getElementById('keyboardHints');
                if (!hints.classList.contains('hidden')) {
                    toggleKeyboardHints();
                }
            }
        });

        // Toggle keyboard hints
        function toggleKeyboardHints() {
            const hints = document.getElementById('keyboardHints');
            hints.classList.toggle('hidden');
        }

        // Copy to clipboard
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            navigator.clipboard.writeText(element.value).then(() => {
                // Visual feedback
                const btn = event.target;
                const originalText = btn.innerHTML;
                btn.innerHTML = '‚úì';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                }, 1000);
            });
        }

        // Load preset
        function loadPreset(func, a, b) {
            document.getElementById('function').value = func;
            document.getElementById('lowerBound').value = a;
            document.getElementById('upperBound').value = b;
            document.getElementById('useBounds').checked = true;
            document.getElementById('boundsInputs').style.display = 'grid';
            validateFunction();
            validateBounds();
            
            // Smooth scroll to calculator
            document.getElementById('calculator').scrollIntoView({ behavior: 'smooth' });
        }

        // Real-time function validation
        function validateFunction() {
            const funcStr = document.getElementById('function').value.trim();
            const input = document.getElementById('function');
            const message = document.getElementById('functionValidation');
            
            if (!funcStr) {
                input.classList.remove('input-valid', 'input-invalid');
                message.textContent = '';
                return;
            }

            try {
                const f = (x) => {
                    const scope = { x: x };
                    return math.evaluate(funcStr, scope);
                };
                f(0); // Test evaluation
                
                input.classList.remove('input-invalid');
                input.classList.add('input-valid');
                message.className = 'validation-message validation-success';
                message.textContent = '‚úì Valid function';
            } catch (e) {
                input.classList.remove('input-valid');
                input.classList.add('input-invalid');
                message.className = 'validation-message validation-error';
                message.textContent = '‚úó Invalid syntax';
            }
        }

        // Real-time bounds validation
        function validateBounds() {
            const a = parseFloat(document.getElementById('lowerBound').value);
            const b = parseFloat(document.getElementById('upperBound').value);
            const message = document.getElementById('boundsValidation');
            
            if (isNaN(a) || isNaN(b)) {
                message.className = 'validation-message validation-error';
                message.textContent = '‚úó Please enter valid numbers';
                return;
            }
            
            if (a >= b) {
                message.className = 'validation-message validation-error';
                message.textContent = '‚úó Lower bound must be less than upper bound';
                return;
            }
            
            // Check if signs are opposite
            const funcStr = document.getElementById('function').value.trim();
            if (funcStr) {
                try {
                    const f = (x) => {
                        const scope = { x: x };
                        return math.evaluate(funcStr, scope);
                    };
                    const fa = f(a);
                    const fb = f(b);
                    
                    if (fa * fb < 0) {
                        message.className = 'validation-message validation-success';
                        message.textContent = '‚úì Root exists in this interval (opposite signs)';
                    } else if (fa * fb > 0) {
                        message.className = 'validation-message validation-error';
                        message.textContent = '‚úó f(a) and f(b) have same sign - no guaranteed root';
                    }
                } catch (e) {
                    message.textContent = '';
                }
            }
        }

        // Plot function graph
        function plotFunctionGraph(funcStr, a, b, root, precision) {
            const resultsDiv = document.getElementById('resultsSection');
            const showGraph = document.getElementById('showGraph').checked;
            
            if (!showGraph) return '';

            // Create canvas
            const canvasId = 'functionGraph';
            const graphHTML = `
                <div class="graph-container">
                    <h3>üìà Function Visualization</h3>
                    <canvas id="${canvasId}"></canvas>
                </div>
            `;
            
            // Add to page first
            setTimeout(() => {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                try {
                    const f = (x) => {
                        const scope = { x: x };
                        return math.evaluate(funcStr, scope);
                    };
                    
                    // Generate data points
                    const range = b - a;
                    const start = a - range * 0.5;
                    const end = b + range * 0.5;
                    const step = (end - start) / 200;
                    
                    const xValues = [];
                    const yValues = [];
                    
                    for (let x = start; x <= end; x += step) {
                        try {
                            const y = f(x);
                            if (isFinite(y)) {
                                xValues.push(x);
                                yValues.push(y);
                            }
                        } catch (e) {
                            // Skip invalid points
                        }
                    }
                    
                    // Create chart
                    new Chart(canvas, {
                        type: 'line',
                        data: {
                            labels: xValues.map(x => x.toFixed(2)),
                            datasets: [{
                                label: 'f(x)',
                                data: yValues,
                                borderColor: getComputedStyle(document.documentElement)
                                    .getPropertyValue('--accent-primary').trim(),
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.4
                            }, {
                                label: 'x-axis',
                                data: Array(xValues.length).fill(0),
                                borderColor: getComputedStyle(document.documentElement)
                                    .getPropertyValue('--text-muted').trim(),
                                borderWidth: 1,
                                borderDash: [5, 5],
                                pointRadius: 0
                            }, {
                                label: 'Root',
                                data: xValues.map(x => {
                                    return Math.abs(x - root) < step * 2 ? f(x) : null;
                                }),
                                borderColor: getComputedStyle(document.documentElement)
                                    .getPropertyValue('--success').trim(),
                                backgroundColor: getComputedStyle(document.documentElement)
                                    .getPropertyValue('--success').trim(),
                                pointRadius: 8,
                                showLine: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            aspectRatio: 2,
                            plugins: {
                                legend: {
                                    display: true,
                                    labels: {
                                        color: getComputedStyle(document.documentElement)
                                            .getPropertyValue('--text-primary').trim()
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false
                                }
                            },
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'x',
                                        color: getComputedStyle(document.documentElement)
                                            .getPropertyValue('--text-primary').trim()
                                    },
                                    ticks: {
                                        maxTicksLimit: 10,
                                        color: getComputedStyle(document.documentElement)
                                            .getPropertyValue('--text-secondary').trim()
                                    },
                                    grid: {
                                        color: getComputedStyle(document.documentElement)
                                            .getPropertyValue('--border-color').trim()
                                    }
                                },
                                y: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'f(x)',
                                        color: getComputedStyle(document.documentElement)
                                            .getPropertyValue('--text-primary').trim()
                                    },
                                    ticks: {
                                        color: getComputedStyle(document.documentElement)
                                            .getPropertyValue('--text-secondary').trim()
                                    },
                                    grid: {
                                        color: getComputedStyle(document.documentElement)
                                            .getPropertyValue('--border-color').trim()
                                    }
                                }
                            }
                        }
                    });
                } catch (e) {
                    console.error('Graph error:', e);
                }
            }, 100);
            
            return graphHTML;
        }

        // Statistics display
        function generateStatistics(iterations, precision) {
            const lastIter = iterations[iterations.length - 1];
            const avgError = iterations.slice(1).reduce((sum, iter) => sum + iter.error, 0) / (iterations.length - 1);
            const maxError = Math.max(...iterations.slice(1).map(iter => iter.error));
            
            return `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${iterations.length}</div>
                        <div class="stat-label">Total Iterations</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${lastIter.x.toFixed(precision)}</div>
                        <div class="stat-label">Final Root</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${Math.abs(lastIter.fx).toFixed(precision)}</div>
                        <div class="stat-label">|f(root)|</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${avgError.toFixed(precision)}</div>
                        <div class="stat-label">Avg Error</div>
                    </div>
                </div>
            `;
        }

        // Compare mode toggle
        let compareMode = false;
        let bisectionIterations = [];

        function toggleCompareMode() {
            compareMode = !compareMode;
            const btn = document.getElementById('compareBtn');
            if (compareMode) {
                btn.style.background = 'var(--accent-primary)';
                btn.style.color = 'white';
            } else {
                btn.style.background = '';
                btn.style.color = '';
            }
        }

        // Bisection method (for comparison)
        function solveBisection(funcStr, a, b, tolerance, maxIter, precision, errorType) {
            const iterations = [];
            
            const f = (x) => {
                const scope = { x: x };
                return math.evaluate(funcStr, scope);
            };
            
            let iter = 0;
            let converged = false;
            
            while (iter < maxIter && !converged) {
                iter++;
                
                const mid = (a + b) / 2;
                const fmid = f(mid);
                const fa = f(a);
                const fb = f(b);
                
                let error = 0;
                if (iter > 1) {
                    const prevX = iterations[iter - 2].x;
                    if (errorType === 'absolute') {
                        error = Math.abs(mid - prevX);
                    } else {
                        error = Math.abs((mid - prevX) / mid) * 100;
                    }
                }
                
                iterations.push({
                    iteration: iter,
                    a: a,
                    b: b,
                    x: mid,
                    fx: fmid,
                    error: error
                });
                
                if (Math.abs(fmid) < tolerance || (iter > 1 && error < tolerance)) {
                    converged = true;
                } else {
                    if (fa * fmid < 0) {
                        b = mid;
                    } else {
                        a = mid;
                    }
                }
            }
            
            return iterations;
        }

        // Global variables for iteration control
        let iterations = [];
        let currentIterationIndex = 0;
        let finalRoot = null;

        // Main solving function
        function solveRegulaFalsi() {
            // Reset
            iterations = [];
            bisectionIterations = [];
            currentIterationIndex = 0;
            finalRoot = null;
            
            const errorDiv = document.getElementById('errorMessage');
            const resultsDiv = document.getElementById('resultsSection');
            errorDiv.innerHTML = '';
            resultsDiv.innerHTML = '';
            resultsDiv.classList.add('hidden');

            // Get inputs
            const funcStr = document.getElementById('function').value.trim();
            const useBounds = document.getElementById('useBounds').checked;
            const tolerance = parseFloat(document.getElementById('tolerance').value);
            const maxIter = parseInt(document.getElementById('maxIterations').value);
            const precision = parseInt(document.getElementById('precision').value);
            const errorType = document.getElementById('errorType').value;

            // Validate inputs
            if (!funcStr) {
                showError('Please enter a function');
                return;
            }

            if (tolerance <= 0) {
                showError('Tolerance must be positive');
                return;
            }

            if (maxIter < 1) {
                showError('Maximum iterations must be at least 1');
                return;
            }

            let a, b;
            
            if (useBounds) {
                a = parseFloat(document.getElementById('lowerBound').value);
                b = parseFloat(document.getElementById('upperBound').value);
                
                if (isNaN(a) || isNaN(b)) {
                    showError('Please enter valid numerical bounds');
                    return;
                }
                
                if (a >= b) {
                    showError('Lower bound must be less than upper bound');
                    return;
                }
            } else {
                // Try to find initial bounds automatically
                const searchResult = findInitialBounds(funcStr);
                if (!searchResult.success) {
                    showError('Could not find an interval containing a root automatically. Please specify bounds manually.');
                    return;
                }
                a = searchResult.a;
                b = searchResult.b;
            }

            // Parse and validate function
            let f;
            try {
                f = (x) => {
                    const scope = { x: x };
                    return math.evaluate(funcStr, scope);
                };
                // Test function
                f(a);
                f(b);
            } catch (e) {
                showError('Invalid function. Error: ' + e.message);
                return;
            }

            // Check if root exists in interval
            const fa = f(a);
            const fb = f(b);
            
            if (fa * fb > 0) {
                showError(`f(${a}) and f(${b}) have the same sign. No root guaranteed in this interval. Please choose a different interval where the function changes sign.`);
                return;
            }

            if (Math.abs(fa) < tolerance) {
                showSuccess(`The lower bound ${a} is already a root!`);
                displayFinalResult(a, fa, 0);
                return;
            }

            if (Math.abs(fb) < tolerance) {
                showSuccess(`The upper bound ${b} is already a root!`);
                displayFinalResult(b, fb, 0);
                return;
            }

            // Perform iterations
            let iter = 0;
            let converged = false;
            let a_curr = a;
            let b_curr = b;
            
            while (iter < maxIter && !converged) {
                iter++;
                
                const fa_curr = f(a_curr);
                const fb_curr = f(b_curr);
                
                // Calculate new approximation
                const x = a_curr - (fa_curr * (b_curr - a_curr)) / (fb_curr - fa_curr);
                const fx = f(x);
                
                // Calculate error
                let error = 0;
                if (iter > 1) {
                    const prevX = iterations[iter - 2].x;
                    if (errorType === 'absolute') {
                        error = Math.abs(x - prevX);
                    } else {
                        error = Math.abs((x - prevX) / x) * 100;
                    }
                }
                
                // Store iteration data
                iterations.push({
                    iteration: iter,
                    a: a_curr,
                    b: b_curr,
                    fa: fa_curr,
                    fb: fb_curr,
                    x: x,
                    fx: fx,
                    error: error
                });
                
                // Check convergence
                if (Math.abs(fx) < tolerance || (iter > 1 && error < tolerance)) {
                    converged = true;
                    finalRoot = x;
                } else {
                    // Update interval
                    if (fa_curr * fx < 0) {
                        b_curr = x;
                    } else {
                        a_curr = x;
                    }
                }
            }

            if (!converged) {
                showWarning(`Method did not converge within ${maxIter} iterations. Try increasing max iterations or adjusting tolerance.`);
            }

            // Compare with bisection if enabled
            if (compareMode) {
                bisectionIterations = solveBisection(funcStr, a, b, tolerance, maxIter, precision, errorType);
            }

            // Display first iteration
            displayIteration(0, precision, funcStr, a, b);
            resultsDiv.classList.remove('hidden');
        }

        function displayIteration(index, precision, funcStr, origA, origB) {
            const resultsDiv = document.getElementById('resultsSection');
            const iter = iterations[index];
            const errorType = document.getElementById('errorType').value;
            const errorUnit = errorType === 'relative' ? '%' : '';
            
            let html = '<div class="results">';
            
            // Progress indicator
            const progress = ((index + 1) / iterations.length) * 100;
            html += `
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progress}%"></div>
                    </div>
                    <div class="progress-text">Iteration ${index + 1} of ${iterations.length}</div>
                </div>
            `;
            
            // Statistics
            if (index === iterations.length - 1) {
                html += generateStatistics(iterations, precision);
            }
            
            // Iteration display
            html += `
                <div class="iteration-display">
                    <h3>Iteration ${iter.iteration} - Detailed Calculation</h3>
                    
                    <div class="calculation-step">
                        <strong>Given Interval:</strong> [${iter.a.toFixed(precision)}, ${iter.b.toFixed(precision)}]
                    </div>
                    
                    <div class="calculation-step">
                        <strong>Function Values:</strong><br>
                        f(a) = f(${iter.a.toFixed(precision)}) = ${iter.fa.toFixed(precision)}<br>
                        f(b) = f(${iter.b.toFixed(precision)}) = ${iter.fb.toFixed(precision)}
                    </div>
                    
                    <div class="calculation-step">
                        <strong>Apply Regula Falsi Formula:</strong><br>
                        x = a - [f(a) √ó (b - a)] / [f(b) - f(a)]<br>
                        x = ${iter.a.toFixed(precision)} - [${iter.fa.toFixed(precision)} √ó (${iter.b.toFixed(precision)} - ${iter.a.toFixed(precision)})] / [${iter.fb.toFixed(precision)} - ${iter.fa.toFixed(precision)}]<br>
                        x = ${iter.x.toFixed(precision)}
                    </div>
                    
                    <div class="calculation-step">
                        <strong>New Function Value:</strong><br>
                        f(x) = f(${iter.x.toFixed(precision)}) = ${iter.fx.toFixed(precision)}
                    </div>
            `;
            
            if (iter.iteration > 1) {
                html += `
                    <div class="calculation-step">
                        <strong>${errorType === 'absolute' ? 'Absolute' : 'Relative'} Error:</strong><br>
                        Error = ${iter.error.toFixed(precision)}${errorUnit}
                    </div>
                `;
            }
            
            html += `
                    <div class="calculation-step" style="background: var(--accent-light); border-left-color: var(--accent-primary); font-weight: 600;">
                        <strong>Next Interval:</strong><br>
                        ${iter.fa * iter.fx < 0 ? 
                            `f(a) √ó f(x) < 0, so root is in [${iter.a.toFixed(precision)}, ${iter.x.toFixed(precision)}]` : 
                            `f(x) √ó f(b) < 0, so root is in [${iter.x.toFixed(precision)}, ${iter.b.toFixed(precision)}]`
                        }
                    </div>
                </div>
            `;
            
            // Buttons
            if (index < iterations.length - 1) {
                html += `
                    <div style="text-align: center; margin: 2rem 0;">
                        <button class="btn btn-primary" onclick="nextIteration(${index + 1}, ${precision}, '${funcStr}', ${origA}, ${origB})">
                            Next Iteration ‚Üí
                        </button>
                        <button class="btn btn-secondary" onclick="skipToEnd(${precision}, '${funcStr}', ${origA}, ${origB})" style="margin-left: 1rem;">
                            Skip to Final Result
                        </button>
                    </div>
                `;
            } else {
                html += `
                    <div class="alert alert-success">
                        <strong>‚úì Converged!</strong> The method has found the root.
                    </div>
                `;
            }
            
            // Graph
            html += plotFunctionGraph(funcStr, origA, origB, iterations[iterations.length - 1].x, precision);
            
            // Always show the complete iteration table
            html += generateIterationTable(precision);
            
            // Comparison table
            if (compareMode && bisectionIterations.length > 0 && index === iterations.length - 1) {
                html += generateComparisonTable(precision);
            }
            
            // Export button
            html += `
                <div style="text-align: center; margin-top: 2rem;">
                    <button class="btn btn-export" onclick="exportToPDF(${precision})">
                        üìÑ Export Table as PDF
                    </button>
                </div>
            `;
            
            html += '</div>';
            
            resultsDiv.innerHTML = html;
        }

        function nextIteration(index, precision, funcStr, origA, origB) {
            currentIterationIndex = index;
            displayIteration(index, precision, funcStr, origA, origB);
            // Smooth scroll to results
            document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function skipToEnd(precision, funcStr, origA, origB) {
            currentIterationIndex = iterations.length - 1;
            displayIteration(iterations.length - 1, precision, funcStr, origA, origB);
            document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function generateIterationTable(precision) {
            const errorType = document.getElementById('errorType').value;
            const errorUnit = errorType === 'relative' ? ' (%)' : '';
            
            let html = `
                <div class="table-container" style="margin-top: 3rem;">
                    <h3 style="margin-bottom: 1rem; color: var(--accent-primary);">Complete Iteration Table</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Iteration</th>
                                <th>a</th>
                                <th>b</th>
                                <th>f(a)</th>
                                <th>f(b)</th>
                                <th>x</th>
                                <th>f(x)</th>
                                <th>Error${errorUnit}</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            iterations.forEach((iter, idx) => {
                const isLast = idx === iterations.length - 1;
                const rowClass = isLast ? 'converged' : '';
                html += `
                    <tr class="${rowClass}">
                        <td>${iter.iteration}</td>
                        <td>${iter.a.toFixed(precision)}</td>
                        <td>${iter.b.toFixed(precision)}</td>
                        <td>${iter.fa.toFixed(precision)}</td>
                        <td>${iter.fb.toFixed(precision)}</td>
                        <td>${iter.x.toFixed(precision)}</td>
                        <td>${iter.fx.toFixed(precision)}</td>
                        <td>${iter.iteration === 1 ? '-' : iter.error.toFixed(precision)}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            if (finalRoot !== null) {
                html += `
                    <div class="alert alert-success" style="margin-top: 2rem;">
                        <strong>‚úì Final Root:</strong> x ‚âà ${iterations[iterations.length - 1].x.toFixed(precision)}<br>
                        <strong>Function Value:</strong> f(x) ‚âà ${iterations[iterations.length - 1].fx.toFixed(precision)}<br>
                        <strong>Total Iterations:</strong> ${iterations.length}
                    </div>
                `;
            }
            
            return html;
        }

        function generateComparisonTable(precision) {
            let html = `
                <div class="compare-mode">
                    <h3 style="color: var(--accent-primary); margin-bottom: 1rem;">üìä Comparison: Regula Falsi vs Bisection Method</h3>
                    
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value">${iterations.length}</div>
                            <div class="stat-label">Regula Falsi Iterations</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${bisectionIterations.length}</div>
                            <div class="stat-label">Bisection Iterations</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${iterations[iterations.length - 1].x.toFixed(precision)}</div>
                            <div class="stat-label">Regula Falsi Root</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${bisectionIterations[bisectionIterations.length - 1].x.toFixed(precision)}</div>
                            <div class="stat-label">Bisection Root</div>
                        </div>
                    </div>
                    
                    <p style="margin-top: 1rem; text-align: center;">
                        <strong>Winner:</strong> ${iterations.length < bisectionIterations.length ? 
                            'Regula Falsi (fewer iterations) üèÜ' : 
                            iterations.length > bisectionIterations.length ?
                            'Bisection (fewer iterations) üèÜ' :
                            'Tie (same iterations) ü§ù'}
                    </p>
                </div>
            `;
            
            return html;
        }

        function exportToPDF(precision) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Title
            doc.setFontSize(18);
            doc.setFont(undefined, 'bold');
            doc.text('Regula Falsi Method - Iteration Results', 14, 20);
            
            // Function info
            doc.setFontSize(11);
            doc.setFont(undefined, 'normal');
            doc.text(`Function: f(x) = ${document.getElementById('function').value}`, 14, 30);
            doc.text(`Tolerance: ${document.getElementById('tolerance').value}`, 14, 37);
            doc.text(`Error Type: ${document.getElementById('errorType').value}`, 14, 44);
            doc.text(`Date: ${new Date().toLocaleDateString()}`, 14, 51);
            
            // Table
            const errorType = document.getElementById('errorType').value;
            const errorUnit = errorType === 'relative' ? ' (%)' : '';
            
            const tableData = iterations.map(iter => [
                iter.iteration,
                iter.a.toFixed(precision),
                iter.b.toFixed(precision),
                iter.fa.toFixed(precision),
                iter.fb.toFixed(precision),
                iter.x.toFixed(precision),
                iter.fx.toFixed(precision),
                iter.iteration === 1 ? '-' : iter.error.toFixed(precision)
            ]);
            
            doc.autoTable({
                startY: 60,
                head: [['Iter', 'a', 'b', 'f(a)', 'f(b)', 'x', 'f(x)', `Error${errorUnit}`]],
                body: tableData,
                theme: 'grid',
                headStyles: { fillColor: [139, 69, 19] },
                styles: { fontSize: 9 }
            });
            
            // Final result
            const finalY = doc.lastAutoTable.finalY + 10;
            doc.setFont(undefined, 'bold');
            doc.text(`Final Root: x ‚âà ${iterations[iterations.length - 1].x.toFixed(precision)}`, 14, finalY);
            doc.setFont(undefined, 'normal');
            doc.text(`f(x) ‚âà ${iterations[iterations.length - 1].fx.toFixed(precision)}`, 14, finalY + 7);
            doc.text(`Total Iterations: ${iterations.length}`, 14, finalY + 14);
            
            // Save
            doc.save('regula-falsi-results.pdf');
        }

        function findInitialBounds(funcStr) {
            try {
                const f = (x) => {
                    const scope = { x: x };
                    return math.evaluate(funcStr, scope);
                };
                
                // Search in range [-100, 100]
                for (let start = -100; start < 100; start += 0.5) {
                    const end = start + 0.5;
                    const fStart = f(start);
                    const fEnd = f(end);
                    
                    if (fStart * fEnd < 0) {
                        return { success: true, a: start, b: end };
                    }
                }
                
                return { success: false };
            } catch (e) {
                return { success: false };
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = `<div class="alert alert-error">${message}</div>`;
        }

        function showWarning(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = `<div class="alert alert-warning">${message}</div>`;
        }

        function showSuccess(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = `<div class="alert alert-success">${message}</div>`;
        }

        function displayFinalResult(root, froot, iters) {
            const precision = parseInt(document.getElementById('precision').value);
            const resultsDiv = document.getElementById('resultsSection');
            resultsDiv.innerHTML = `
                <div class="results">
                    <div class="alert alert-success">
                        <strong>‚úì Root Found!</strong><br>
                        x = ${root.toFixed(precision)}<br>
                        f(x) = ${froot.toFixed(precision)}<br>
                        Iterations: ${iters}
                    </div>
                </div>
            `;
            resultsDiv.classList.remove('hidden');
        }

        function resetCalculator() {
            document.getElementById('function').value = 'x^3 - x - 1';
            document.getElementById('lowerBound').value = '1';
            document.getElementById('upperBound').value = '2';
            document.getElementById('tolerance').value = '0.0001';
            document.getElementById('precision').value = '6';
            document.getElementById('maxIterations').value = '100';
            document.getElementById('errorType').value = 'absolute';
            document.getElementById('useBounds').checked = true;
            document.getElementById('showGraph').checked = true;
            document.getElementById('errorMessage').innerHTML = '';
            document.getElementById('resultsSection').innerHTML = '';
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('functionValidation').textContent = '';
            document.getElementById('boundsValidation').textContent = '';
            document.getElementById('function').classList.remove('input-valid', 'input-invalid');
            iterations = [];
            bisectionIterations = [];
            currentIterationIndex = 0;
            finalRoot = null;
            compareMode = false;
            document.getElementById('compareBtn').style.background = '';
            document.getElementById('compareBtn').style.color = '';
        }
    </script>
</body>
</html>